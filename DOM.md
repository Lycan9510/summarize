## DOM 事件机制
DOM 事件机制有三个阶段，分别是：捕获阶段，目标阶段和冒泡阶段。

>绑定函数执行顺序可以通过addEventListener的第三个参数控制。e.addEventLisenter('click',f2,true)   // true按捕获方向执行函数。e.addEventLisenter('click',f2,false)  //  false按冒泡方向执行函数


### 1. 捕获&冒泡

当一个事件发生在具有父元素的元素上时，现代浏览器运行两个不同的阶段 - 捕获阶段和冒泡阶段。

在捕获阶段：

当用户点击dom，浏览器会从 window 从上向下遍历至用户点击的dom，逐个触发事件处理函数。

在冒泡阶段：

浏览器从用户点击的dom从下往上遍历至 window，逐个触发事件处理函数。

### 2. 取消冒泡

W3C的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true。 stopPropagation是事件的一个方法，作用是阻止目标元素的事件冒泡，但是不会组织默认行为

```
window.event? window.event.cancelBubble = true : e.stopPropagation();
```

### 3. 取消默认事件
W3C的方法是e.preventDefault()，IE则是使用e.returnValue = false。
preventDefault()是事件对象(Event)的一个方法，作用是取消一个目标元素的默认行为。既然是默认行为，那么元素必须有默认行为才能被取消，如果元素本身就没有默认行为，调用自然就无效了。什么元素有默认行为呢？如链接，提交按钮等，这些都有默认行为。

### 4. 事件委托

事件委托是指利用事件冒泡原理，只指定一个事件处理程序，使用这一个事件处理程序管理一系列的同类型事件。

### 5. 事件委托好处

1. 可以节省内存开销，减少事件的注册
2. 可以减少操作DOM元素，提升网页性能
3. 可以方便地动态添加和修改元素，不需要因为元素的变化而修改绑定

>另外需要注意的是事件委托并不适合所有事件，因为有的事件不能冒泡，比如blur,focus,load,unload等特殊事件。

### 6. 虚拟DOM

虚拟DOM是一颗以JavaScript对象（node节点）作为基础的树，用对象属性来描述节点，他是对真实DOM的抽象，通过一些列操作使这棵树映射到真实环境上

虚拟dom就是能代表DOM树的对象，通常含有标签名，标签上的属性，事件监听和子元素们以及其它属性

### 7. 虚拟DOM优点

1. 减少DOM的操作
2. 跨平台渲染

### 8. DOM diff

DOM diff 是两个虚拟 DOM 树对比的算法：diff 算法仅在两个树的同级的虚拟节点之间做比较，递归地进行比较，最终实现整个 DOM 树的更新。

#### diff算法的三个步骤：

用 JS 对象的方式来表示 DOM 树的结构，然后根据这个对象构建出真实的 DOM 树，插到文档中
当状态变化的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树的差异
最后把所记录的差异应用到所构建的真正的DOM树上，进行视图更新

#### DOM diff 在做比较时分为了三个层级

1. Tree Diff（层级比较）

    1. 先进行树结构的层级比较，对同一个父节点下的所有子节点进行比较；
    2. 接着看节点是什么类型的，是组件就做 Component Diff;
    3. 如果节点是标签或者元素，就做 Element Diff;

2. omponent Diff （组件比较）

    1. 若组件类型相同，则继续按照层级比较其虚拟 DOM的结构;
    2. 如果组件类型不同，则替换整个组件的所有内容

3. Element Diff (元素比较)

    1. 如果节点是原生标签，则看标签名做比较是否相同来决定替换还是更新属性
    2. 然后进入标签后代递归 Tree Diff

#### 没有key值的问题
同级比较存在bug,做元素比较的时候，当 DOM 处于同一层级的时候，diff 提供了三个节点操作，分别是：删除、插入和移动

1. 会造成整个集合的删除再新增，不会进行移动 DOM 操作。

2. 导致更新数据的 bug。React/Vue 判断是变化前后是同类型组件，并且 props 的内容并没有改变，不会触发改变。

### Diff算法的提升

1. 以往的渲染策略
vue2.x提供类似于HTML的模板语法，但是，它是将模板编译成渲染函数来返回虚拟DOM树。Vue框架通过递归遍历两个虚拟DOM树，并比较每个节点上的每个属性，来确定实际DOM的哪些部分需要更新。

2. 潜在的问题
由于现代JavaScript引擎执行的高级优化，这种有点暴力的算法通常非常快速，但是DOM的更新仍然涉及许多不必要的CPU工作，那么如何解决呢？

3. Vue3的突破
为了实现这一点，编译器和运行时需要协同工作：编译器分析模板并生成带有优化提示的代码，而运行时尽可能获取提示并采用快速路径。这里有三个主要的优化：


    1. 在DOM树级别。我们注意到，在没有动态改变节点结构的模板指令（例如v-if和v-for）的情况下，节点结构保持完全静态。如果我们将一个模板分成由这些结构指令分隔的嵌套“块”，则每个块中的节点结构将再次完全静态。当我们更新块中的节点时，我们不再需要递归遍历DOM树 - 该块内的动态绑定可以在一个平面数组中跟踪。这种优化通过将需要执行的树遍历量减少一个数量级来规避虚拟DOM的大部分开销。


    2. 编译器积极地检测模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提升到渲染函数之外。这样可以避免在每次渲染时重新创建这些对象，从而大大提高内存使用率并减少垃圾回收的频率。


    3. 在元素级别。编译器还根据需要执行的更新类型，为每个具有动态绑定的元素生成一个优化标志。例如，具有动态类绑定和许多静态属性的元素将收到一个标志，提示只需要进行类检查。运行时将获取这些提示并采用专用的快速路径。

