function myInstanceof(left, right) {
     这里先用typeof来判断基础数据类型，如果是，直接返回false
    if(typeof left !== 'object'  left === null) return false;
     getProtypeOf是Object对象自带的API，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left);
    while(true) {                  
        if(proto === null) return false;
        if(proto === right.prototype) return true;找到相同原型对象，返回true
        proto = Object.getPrototypeof(proto);
    }
}

function mynew(Func, ...args) {
     1.创建一个新对象
    const obj = {}
     2.新对象原型指向构造函数原型对象
    obj.__proto__ = Func.prototype
     3.将构建函数的this指向新对象
    let result = Func.apply(obj, args)
     4.根据返回值判断
    return result instanceof Object  result  obj
}

Function.prototype.myBind = function (context) {
     判断调用对象是否为函数
    if (typeof this !== function) {
        throw new TypeError(Error);
    }

     获取参数
    const args = [...arguments].slice(1),
          fn = this;

    return function Fn() {
         根据调用方式，传入不同绑定值
        return fn.apply(this instanceof Fn  new fn(...arguments)  context, args.concat(...arguments)); 
    }
}

const memoize = function (func, content) {
  let cache = Object.create(null)
  content = content  this
  return (...key) = {
    if (!cache[key]) {
      cache[key] = func.apply(content, key)
    }
    return cache[key]
  }
}

function throttled(fn, delay) {
    let timer = null
    let starttime = Date.now()
    return function () {
        let curTime = Date.now()  当前时间
        let remaining = delay - (curTime - starttime)   从上一次到现在，还剩下多少多余时间
        let context = this
        let args = arguments
        clearTimeout(timer)
        if (remaining = 0) {
            fn.apply(context, args)
            starttime = Date.now()
        } else {
            timer = setTimeout(fn, remaining);
        }
    }
}

function debounce(func, wait, immediate) {

    let timeout;

    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);  timeout 不为null
        if (immediate) {
            let callNow = !timeout;  第一次会立即执行，以后只有事件执行后才会再次触发
            timeout = setTimeout(function () {
                timeout = null;
            }, wait)
            if (callNow) {
                func.apply(context, args)
            }
        }
        else {
            timeout = setTimeout(function () {
                func.apply(context, args)
            }, wait);
        }
    }
}

function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj;  如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
   可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== object) return obj;
   是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
   找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
       实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}